"""
Advent of Code 2015 - Day 25: Let It Snow

This script calculates the code required for the weather machine by simulating
the diagonal sequence generation. 
The code was created and published by UlaÅŸ Bardak and is licensed under the
Mozilla Public License 2.0. The MPL 2.0 is a weak copyleft license that allows
for the modification and distribution of the code, but requires that any changes
to the code be made available under the same license.
"""

import argparse
import logging
import os
import re

# Configure logging
logging.basicConfig(level=logging.INFO, format="%(levelname)s: %(message)s")
logger = logging.getLogger(__name__)

DEFAULT_INPUT_FILE = "input.txt"

# Constants for the weather machine sequence
INITIAL_CODE = 20151125
MULTIPLIER = 252533
MODULUS = 33554393

# Default target coordinates
DEFAULT_ROW = 2947
DEFAULT_COL = 3029


def read_input(filename: str = DEFAULT_INPUT_FILE) -> tuple[int, int]:
    """
    Read the target row and column from the input file.

    Parameters
    ----------
    filename : str, optional
        The path to the input file (default is "input.txt").

    Returns
    -------
    tuple[int, int]
        A tuple containing (row, column).

    Raises
    ------
    FileNotFoundError
        If the input file doesn't exist.
    ValueError
        If the row or column cannot be found in the file.
    """

    if not os.path.exists(filename):
        raise FileNotFoundError(f"Input file '{filename}' not found.")

    with open(filename, "r") as f:
        content = f.read()

    # Look for "row <num>" and "column <num>"
    row_match = re.search(r"row (\d+)", content)
    col_match = re.search(r"column (\d+)", content)

    if not row_match or not col_match:
        raise ValueError(f"Could not find row and column in {filename}")

    return int(row_match.group(1)), int(col_match.group(1))


def get_index(row: int, col: int) -> int:
    """
    Calculate the 1-based index in the diagonal sequence.

    The sequence proceeds diagonally:
    (1,1) -> 1
    (2,1) -> 2, (1,2) -> 3
    (3,1) -> 4, (2,2) -> 5, (1,3) -> 6
    ...

    Parameters
    ----------
    row : int
        The row number (1-based).
    col : int
        The column number (1-based).

    Returns
    -------
    int
        The index of the code at the given row and column.
    """
    # The sum of row + col is constant along a diagonal.
    # For index (r, c), it's in the (r+c-1)-th diagonal.
    # The number of elements in previous diagonals is sum(1 to r+c-2).
    return ((row + col - 2) * (row + col - 1)) // 2 + col


def get_code(row: int, col: int) -> int:
    """
    Calculate the code for a given row and column using the sequence logic.

    The first code is 20151125. Each subsequent code is generated by
    multiplying the previous code by 252533 and taking the remainder
    modulo 33554393.

    Parameters
    ----------
    row : int
        The row number (1-based).
    col : int
        The column number (1-based).

    Returns
    -------
    int
        The code value at the specified position.
    """
    index = get_index(row, col)

    # Using modular exponentiation for efficiency:
    # code = (INITIAL_CODE * (MULTIPLIER ** (index - 1))) % MODULUS
    return (INITIAL_CODE * pow(MULTIPLIER, index - 1, MODULUS)) % MODULUS


def parse_arguments():
    """
    Parse command line arguments.

    Returns
    -------
    argparse.Namespace
        The parsed arguments.
    """
    parser = argparse.ArgumentParser(description="Advent of Code 2015 Day 25 Solver")
    parser.add_argument(
        "file",
        nargs="?",
        default=DEFAULT_INPUT_FILE,
        help="Path to the input file (default: input.txt)",
    )
    return parser.parse_args()


def main():
    """Main entry point for the script."""
    args = parse_arguments()

    try:
        row, col = read_input(args.file)
        logger.info(f"Read target from {args.file}: row {row}, column {col}")
    except (FileNotFoundError, ValueError) as e:
        logger.warning(f"Using default coordinates due to error: {e}")
        row, col = DEFAULT_ROW, DEFAULT_COL

    result = get_code(row, col)
    logger.info(f"Code at row {row}, column {col}: {result}")


if __name__ == "__main__":
    main()